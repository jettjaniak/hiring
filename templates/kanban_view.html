{% extends "base.html" %}

{% block title %}Kanban Board - Hiring Process Management{% endblock %}

{% block extra_css %}
<style>
    .kanban-board {
        display: flex;
        gap: 20px;
        padding: 20px;
        overflow-x: auto;
    }

    .kanban-column {
        flex: 1;
        min-width: 300px;
        background: #f5f5f5;
        border-radius: 8px;
        padding: 15px;
    }

    .kanban-column h2 {
        margin-top: 0;
        padding-bottom: 10px;
        border-bottom: 2px solid #ddd;
        font-size: 18px;
        text-transform: uppercase;
        color: #555;
    }

    .kanban-column.todo h2 {
        border-color: #3498db;
        color: #3498db;
    }

    .kanban-column.in-progress h2 {
        border-color: #f39c12;
        color: #f39c12;
    }

    .kanban-column.done h2 {
        border-color: #27ae60;
        color: #27ae60;
    }

    .kanban-cards {
        min-height: 200px;
    }

    .kanban-card {
        background: white;
        border-radius: 6px;
        padding: 12px;
        margin-bottom: 10px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        cursor: move;
        transition: all 0.2s;
        position: relative;
    }

    .kanban-card:hover {
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        transform: translateY(-2px);
    }

    .kanban-card.dragging {
        opacity: 0.5;
    }

    .kanban-card h3 {
        margin: 0 0 8px 0;
        font-size: 16px;
        color: #333;
        padding-right: 24px;
    }

    .kanban-card p {
        margin: 0 0 8px 0;
        font-size: 14px;
        color: #666;
    }

    .ad-hoc-icon {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #9e9e9e;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
        cursor: help;
    }

    .card-badges {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 8px;
    }

    .badge {
        display: inline-block;
        padding: 3px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 500;
    }

    .badge.candidate {
        /* Colors are set dynamically via JavaScript - light background */
    }

    .badge.user {
        /* Dark background with light text to distinguish from candidates */
        background: #2c3e50;
        color: #ecf0f1;
    }

    .kanban-column.drag-over {
        background: #e8e8e8;
        border: 2px dashed #999;
    }

    .page-header {
        display: flex;
        align-items: center;
        gap: 15px;
        padding: 20px;
        padding-bottom: 10px;
    }

    .page-header h2 {
        margin: 0;
    }

    .custom-select {
        position: relative;
        min-width: 200px;
    }

    .select-button {
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid #ddd;
        font-size: 14px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        background: white;
    }

    .select-button:hover {
        border-color: #999;
    }

    .select-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        margin-top: 4px;
        background: white;
        border: 1px solid #ddd;
        border-radius: 6px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        max-height: 300px;
        overflow-y: auto;
        display: none;
        z-index: 1000;
    }

    .select-dropdown.open {
        display: block;
    }

    .select-option {
        padding: 8px 12px;
        cursor: pointer;
        transition: background 0.2s;
    }

    .select-option:hover {
        background: #f5f5f5;
    }

    .select-arrow {
        font-size: 12px;
    }
</style>
{% endblock %}

{% block content %}
<div class="page-header">
    <h2>Kanban Board</h2>
    <div class="custom-select">
        <div class="select-button" id="selectButton">
            <span id="selectedText">All Candidates</span>
            <span class="select-arrow">â–¼</span>
        </div>
        <div class="select-dropdown" id="selectDropdown">
            <div class="select-option" data-value="">All Candidates</div>
        </div>
    </div>
</div>

<div class="kanban-board">
    <!-- To Do Column -->
    <div class="kanban-column todo" data-status="todo">
        <h2>To Do (<span class="count">0</span>)</h2>
        <div class="kanban-cards"></div>
    </div>

    <!-- In Progress Column -->
    <div class="kanban-column in-progress" data-status="in_progress">
        <h2>In Progress (<span class="count">0</span>)</h2>
        <div class="kanban-cards"></div>
    </div>

    <!-- Done Column -->
    <div class="kanban-column done" data-status="done">
        <h2>Done (<span class="count">0</span>)</h2>
        <div class="kanban-cards"></div>
    </div>
</div>

<script>
// Get current filter from URL query parameter
function getCurrentFilter() {
    const params = new URLSearchParams(window.location.search);
    return {
        type: params.get('filter_type') || '',  // 'candidate' or 'user'
        value: params.get('filter_value') || ''
    };
}

// Fetch and display kanban data
async function loadKanbanData() {
    try {
        const filter = getCurrentFilter();
        let url = '/api/tasks/kanban';

        // Add appropriate filter parameter based on type
        if (filter.type === 'candidate') {
            url += `?candidate_email=${encodeURIComponent(filter.value)}`;
        } else if (filter.type === 'user') {
            url += `?assigned_to=${encodeURIComponent(filter.value)}`;
        }

        const response = await fetch(url);
        const data = await response.json();

        // Update filter dropdown
        await updateFilterDropdown();

        // Display data
        displayKanbanData(data);
    } catch (error) {
        console.error('Error loading kanban data:', error);
    }
}

// Update the filter dropdown with both candidates and users
async function updateFilterDropdown() {
    try {
        // Fetch all kanban data (unfiltered) to get all candidates and users
        const response = await fetch('/api/tasks/kanban');
        const data = await response.json();

        const candidatesMap = new Map();
        const usersMap = new Map();

        // Extract all unique candidates and users from all tasks
        for (const [status, tasks] of Object.entries(data)) {
            tasks.forEach(task => {
                // Collect candidates
                if (task.candidates && task.candidates.length > 0) {
                    task.candidates.forEach(candidate => {
                        const key = candidate.email || candidate.name;
                        if (!candidatesMap.has(key)) {
                            candidatesMap.set(key, candidate);
                        }
                    });
                }

                // Collect assigned users
                if (task.assigned_user) {
                    const key = task.assigned_user.username;
                    if (!usersMap.has(key)) {
                        usersMap.set(key, task.assigned_user);
                    }
                }
            });
        }

        // Get the dropdown element
        const dropdown = document.getElementById('selectDropdown');
        const filter = getCurrentFilter();

        // Start with "All Tasks" option
        dropdown.innerHTML = '<div class="select-option" data-type="" data-value="">All Tasks</div>';

        // Add "Unassigned Candidates" option
        const unassignedCandidatesOption = document.createElement('div');
        unassignedCandidatesOption.className = 'select-option';
        unassignedCandidatesOption.dataset.type = 'candidate';
        unassignedCandidatesOption.dataset.value = 'unassigned';
        unassignedCandidatesOption.textContent = 'Unassigned Candidates';
        unassignedCandidatesOption.style.backgroundColor = '#f5f5f5';
        unassignedCandidatesOption.style.color = '#666';
        dropdown.appendChild(unassignedCandidatesOption);

        // Add candidate options with light colors
        candidatesMap.forEach((candidate, key) => {
            const option = document.createElement('div');
            option.className = 'select-option';
            option.dataset.type = 'candidate';
            option.dataset.value = key;
            option.textContent = `ðŸ‘¤ ${candidate.name}`;

            const bgColor = getColorFromHash(key, true);
            const textColor = getColorFromHash(key, false);
            option.style.backgroundColor = bgColor;
            option.style.color = textColor;

            dropdown.appendChild(option);
        });

        // Add "Unassigned Users" option
        const unassignedUsersOption = document.createElement('div');
        unassignedUsersOption.className = 'select-option';
        unassignedUsersOption.dataset.type = 'user';
        unassignedUsersOption.dataset.value = 'unassigned';
        unassignedUsersOption.textContent = 'Unassigned to Users';
        unassignedUsersOption.style.backgroundColor = '#f5f5f5';
        unassignedUsersOption.style.color = '#666';
        dropdown.appendChild(unassignedUsersOption);

        // Add user options with dark background
        usersMap.forEach((user, key) => {
            const option = document.createElement('div');
            option.className = 'select-option';
            option.dataset.type = 'user';
            option.dataset.value = key;
            option.textContent = `ðŸ§‘ ${user.full_name}`;

            option.style.backgroundColor = '#2c3e50';
            option.style.color = '#ecf0f1';

            dropdown.appendChild(option);
        });

        // Update the selected text to match current filter
        const selectedText = document.getElementById('selectedText');
        if (!filter.type || !filter.value) {
            selectedText.textContent = 'All Tasks';
            selectedText.style.backgroundColor = '';
            selectedText.style.color = '';
            selectedText.style.padding = '';
            selectedText.style.borderRadius = '';
        } else if (filter.type === 'candidate') {
            if (filter.value === 'unassigned') {
                selectedText.textContent = 'Unassigned Candidates';
                selectedText.style.backgroundColor = '#f5f5f5';
                selectedText.style.color = '#666';
            } else {
                const candidate = candidatesMap.get(filter.value);
                if (candidate) {
                    selectedText.textContent = `ðŸ‘¤ ${candidate.name}`;
                    selectedText.style.backgroundColor = getColorFromHash(filter.value, true);
                    selectedText.style.color = getColorFromHash(filter.value, false);
                }
            }
            selectedText.style.padding = '3px 8px';
            selectedText.style.borderRadius = '4px';
        } else if (filter.type === 'user') {
            if (filter.value === 'unassigned') {
                selectedText.textContent = 'Unassigned to Users';
                selectedText.style.backgroundColor = '#f5f5f5';
                selectedText.style.color = '#666';
            } else {
                const user = usersMap.get(filter.value);
                if (user) {
                    selectedText.textContent = `ðŸ§‘ ${user.full_name}`;
                    selectedText.style.backgroundColor = '#2c3e50';
                    selectedText.style.color = '#ecf0f1';
                }
            }
            selectedText.style.padding = '3px 8px';
            selectedText.style.borderRadius = '4px';
        }
    } catch (error) {
        console.error('Error updating filter dropdown:', error);
    }
}

// Display kanban data with optional filtering
function displayKanbanData(data) {
    // Clear existing cards
    document.querySelectorAll('.kanban-cards').forEach(el => el.innerHTML = '');

    // Populate each column
    for (const [status, tasks] of Object.entries(data)) {
        const column = document.querySelector(`.kanban-column[data-status="${status}"]`);
        const cardsContainer = column.querySelector('.kanban-cards');
        const countSpan = column.querySelector('.count');

        countSpan.textContent = tasks.length;

        tasks.forEach(task => {
            const card = createTaskCard(task);
            cardsContainer.appendChild(card);
        });
    }
}

// Hash function to generate consistent color from string
function hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash = hash & hash;
    }
    return Math.abs(hash);
}

// Generate vibrant color from hash
function getColorFromHash(str, forBackground) {
    const hash = hashString(str);
    const hue = hash % 360; // Random hue across full spectrum

    if (forBackground) {
        // Background: vibrant with opacity
        return `hsla(${hue}, 90%, 45%, 0.3)`;
    } else {
        // Text: darker version of the same hue
        return `hsl(${hue}, 75%, 20%)`;
    }
}

// Create a task card element
function createTaskCard(task) {
    const card = document.createElement('div');
    card.className = 'kanban-card';
    card.draggable = true;
    card.dataset.taskId = task.id;

    const title = document.createElement('h3');
    title.textContent = task.title;
    card.appendChild(title);

    // Add ad-hoc icon if task has no template
    if (!task.template_id) {
        const adHocIcon = document.createElement('div');
        adHocIcon.className = 'ad-hoc-icon';
        adHocIcon.textContent = 'A';
        adHocIcon.title = 'Ad-hoc task (not from template)';
        card.appendChild(adHocIcon);
    }

    if (task.description) {
        const desc = document.createElement('p');
        desc.textContent = task.description;
        card.appendChild(desc);
    }

    const badges = document.createElement('div');
    badges.className = 'card-badges';

    // Add candidate badges (light background)
    if (task.candidates && task.candidates.length > 0) {
        task.candidates.forEach(candidate => {
            const candidateBadge = document.createElement('span');
            candidateBadge.className = 'badge candidate';
            candidateBadge.textContent = candidate.name;

            // Use email for hashing, fallback to name
            const hashKey = candidate.email || candidate.name;
            const bgColor = getColorFromHash(hashKey, true);  // true = background
            const textColor = getColorFromHash(hashKey, false); // false = text

            candidateBadge.style.backgroundColor = bgColor;
            candidateBadge.style.color = textColor;

            badges.appendChild(candidateBadge);
        });
    }

    // Add user badge (dark background to distinguish from candidates)
    if (task.assigned_user) {
        const userBadge = document.createElement('span');
        userBadge.className = 'badge user';
        userBadge.textContent = `ðŸ§‘ ${task.assigned_user.full_name}`;
        badges.appendChild(userBadge);
    }

    card.appendChild(badges);

    // Add drag event listeners
    card.addEventListener('dragstart', handleDragStart);
    card.addEventListener('dragend', handleDragEnd);

    return card;
}

// Drag and drop handlers
let draggedCard = null;

function handleDragStart(e) {
    draggedCard = e.target;
    e.target.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', e.target.innerHTML);
}

function handleDragEnd(e) {
    e.target.classList.remove('dragging');
}

function handleDragOver(e) {
    if (e.preventDefault) {
        e.preventDefault();
    }
    e.dataTransfer.dropEffect = 'move';
    return false;
}

function handleDragEnter(e) {
    e.currentTarget.classList.add('drag-over');
}

function handleDragLeave(e) {
    e.currentTarget.classList.remove('drag-over');
}

async function handleDrop(e) {
    if (e.stopPropagation) {
        e.stopPropagation();
    }

    e.currentTarget.classList.remove('drag-over');

    if (draggedCard) {
        const newStatus = e.currentTarget.dataset.status;
        const taskId = draggedCard.dataset.taskId;

        // Update task status via API
        try {
            const response = await fetch(`/api/tasks/${taskId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ status: newStatus })
            });

            if (response.ok) {
                // Reload kanban data
                await loadKanbanData();
            } else {
                console.error('Failed to update task status');
                alert('Failed to update task status');
            }
        } catch (error) {
            console.error('Error updating task:', error);
            alert('Error updating task');
        }
    }

    return false;
}

// Custom dropdown event handlers
const selectButton = document.getElementById('selectButton');
const selectDropdown = document.getElementById('selectDropdown');
const selectedText = document.getElementById('selectedText');

selectButton.addEventListener('click', () => {
    selectDropdown.classList.toggle('open');
});

// Close dropdown when clicking outside
document.addEventListener('click', (e) => {
    if (!e.target.closest('.custom-select')) {
        selectDropdown.classList.remove('open');
    }
});

// Handle option selection
selectDropdown.addEventListener('click', (e) => {
    const option = e.target.closest('.select-option');
    if (option) {
        const type = option.dataset.type;
        const value = option.dataset.value;

        // Navigate to the filtered URL
        if (type && value) {
            window.location.href = `/kanban?filter_type=${encodeURIComponent(type)}&filter_value=${encodeURIComponent(value)}`;
        } else {
            window.location.href = '/kanban';
        }
    }
});

// Add event listeners to columns
document.querySelectorAll('.kanban-column').forEach(column => {
    column.addEventListener('dragover', handleDragOver);
    column.addEventListener('dragenter', handleDragEnter);
    column.addEventListener('dragleave', handleDragLeave);
    column.addEventListener('drop', handleDrop);
});

// Load data on page load
loadKanbanData();
</script>
{% endblock %}
