{% extends "base.html" %}

{% block title %}Kanban Board - Hiring Process Management{% endblock %}

{% block extra_css %}
<style>
    .kanban-board {
        display: flex;
        gap: 20px;
        padding: 20px;
        overflow-x: auto;
    }

    .kanban-column {
        flex: 1;
        min-width: 300px;
        background: #f5f5f5;
        border-radius: 8px;
        padding: 15px;
    }

    .kanban-column h2 {
        margin-top: 0;
        padding-bottom: 10px;
        border-bottom: 2px solid #ddd;
        font-size: 18px;
        text-transform: uppercase;
        color: #555;
    }

    .kanban-column.todo h2 {
        border-color: #3498db;
        color: #3498db;
    }

    .kanban-column.in-progress h2 {
        border-color: #f39c12;
        color: #f39c12;
    }

    .kanban-column.done h2 {
        border-color: #27ae60;
        color: #27ae60;
    }

    .kanban-cards {
        min-height: 200px;
    }

    .kanban-card {
        background: white;
        border-radius: 6px;
        padding: 12px;
        margin-bottom: 10px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        cursor: move;
        transition: all 0.2s;
    }

    .kanban-card:hover {
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        transform: translateY(-2px);
    }

    .kanban-card.dragging {
        opacity: 0.5;
    }

    .kanban-card h3 {
        margin: 0 0 8px 0;
        font-size: 16px;
        color: #333;
    }

    .kanban-card p {
        margin: 0 0 8px 0;
        font-size: 14px;
        color: #666;
    }

    .card-badges {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 8px;
    }

    .badge {
        display: inline-block;
        padding: 3px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 500;
    }

    .badge.template {
        background: #e3f2fd;
        color: #1976d2;
    }

    .badge.workflow {
        background: #f3e5f5;
        color: #7b1fa2;
    }

    .badge.candidate {
        background: #e8f5e9;
        color: #388e3c;
    }

    .kanban-column.drag-over {
        background: #e8e8e8;
        border: 2px dashed #999;
    }
</style>
{% endblock %}

{% block content %}
<h2>Kanban Board</h2>

<div class="kanban-board">
    <!-- To Do Column -->
    <div class="kanban-column todo" data-status="todo">
        <h2>To Do (<span class="count">0</span>)</h2>
        <div class="kanban-cards"></div>
    </div>

    <!-- In Progress Column -->
    <div class="kanban-column in-progress" data-status="in_progress">
        <h2>In Progress (<span class="count">0</span>)</h2>
        <div class="kanban-cards"></div>
    </div>

    <!-- Done Column -->
    <div class="kanban-column done" data-status="done">
        <h2>Done (<span class="count">0</span>)</h2>
        <div class="kanban-cards"></div>
    </div>
</div>

<script>
// Fetch and display kanban data
async function loadKanbanData() {
    try {
        const response = await fetch('/api/tasks/kanban');
        const data = await response.json();

        // Clear existing cards
        document.querySelectorAll('.kanban-cards').forEach(el => el.innerHTML = '');

        // Populate each column
        for (const [status, tasks] of Object.entries(data)) {
            const column = document.querySelector(`.kanban-column[data-status="${status}"]`);
            const cardsContainer = column.querySelector('.kanban-cards');
            const countSpan = column.querySelector('.count');

            countSpan.textContent = tasks.length;

            tasks.forEach(task => {
                const card = createTaskCard(task);
                cardsContainer.appendChild(card);
            });
        }
    } catch (error) {
        console.error('Error loading kanban data:', error);
    }
}

// Create a task card element
function createTaskCard(task) {
    const card = document.createElement('div');
    card.className = 'kanban-card';
    card.draggable = true;
    card.dataset.taskId = task.id;

    const title = document.createElement('h3');
    title.textContent = task.title;
    card.appendChild(title);

    if (task.description) {
        const desc = document.createElement('p');
        desc.textContent = task.description;
        card.appendChild(desc);
    }

    const badges = document.createElement('div');
    badges.className = 'card-badges';

    if (task.template_id) {
        const templateBadge = document.createElement('span');
        templateBadge.className = 'badge template';
        templateBadge.textContent = `Template: ${task.template_id}`;
        badges.appendChild(templateBadge);
    }

    if (task.workflow_id) {
        const workflowBadge = document.createElement('span');
        workflowBadge.className = 'badge workflow';
        workflowBadge.textContent = `Workflow: ${task.workflow_id}`;
        badges.appendChild(workflowBadge);
    }

    if (task.candidates && task.candidates.length > 0) {
        task.candidates.forEach(candidate => {
            const candidateBadge = document.createElement('span');
            candidateBadge.className = 'badge candidate';
            candidateBadge.textContent = candidate.name;
            badges.appendChild(candidateBadge);
        });
    }

    card.appendChild(badges);

    // Add drag event listeners
    card.addEventListener('dragstart', handleDragStart);
    card.addEventListener('dragend', handleDragEnd);

    return card;
}

// Drag and drop handlers
let draggedCard = null;

function handleDragStart(e) {
    draggedCard = e.target;
    e.target.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', e.target.innerHTML);
}

function handleDragEnd(e) {
    e.target.classList.remove('dragging');
}

function handleDragOver(e) {
    if (e.preventDefault) {
        e.preventDefault();
    }
    e.dataTransfer.dropEffect = 'move';
    return false;
}

function handleDragEnter(e) {
    e.currentTarget.classList.add('drag-over');
}

function handleDragLeave(e) {
    e.currentTarget.classList.remove('drag-over');
}

async function handleDrop(e) {
    if (e.stopPropagation) {
        e.stopPropagation();
    }

    e.currentTarget.classList.remove('drag-over');

    if (draggedCard) {
        const newStatus = e.currentTarget.dataset.status;
        const taskId = draggedCard.dataset.taskId;

        // Update task status via API
        try {
            const response = await fetch(`/api/tasks/${taskId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ status: newStatus })
            });

            if (response.ok) {
                // Reload kanban data
                await loadKanbanData();
            } else {
                console.error('Failed to update task status');
                alert('Failed to update task status');
            }
        } catch (error) {
            console.error('Error updating task:', error);
            alert('Error updating task');
        }
    }

    return false;
}

// Add event listeners to columns
document.querySelectorAll('.kanban-column').forEach(column => {
    column.addEventListener('dragover', handleDragOver);
    column.addEventListener('dragenter', handleDragEnter);
    column.addEventListener('dragleave', handleDragLeave);
    column.addEventListener('drop', handleDrop);
});

// Load data on page load
loadKanbanData();
</script>
{% endblock %}
